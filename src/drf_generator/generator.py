#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Transforms a DRF glob into a list of valid requests.
"""

from itertools import product
from pathlib import Path
import re
from typing import Generator, List, Tuple, Union


def char_range(char_1: str, char_2: str) -> Generator[str, None, None]:
    """
    Generates a list of characters between two characters, inclusive.

    :param char_1: The first character.
    :param char_2: The second character.
    :return: A list of characters.
    """
    for char in range(ord(char_1), ord(char_2)+1):
        yield chr(char)


Token = Union[int, str, float]


def token_range(first: str, second: str) -> List[Token]:
    """
    Generates a list of tokens between two tokens, inclusive.

    :param first: The first token.
    :param second: The second token.
    :return: A list of tokens.
    """
    if first.isnumeric():
        if len(first) > 1:
            pad_length = len(first)
            pad_character = first[0]

            return list(map(
                lambda x: f'{x:{pad_character}{pad_length}d}',
                range(int(first), int(second) + 1)
            ))

        # In case we don't have a padded number
        return list(range(int(first), int(second) + 1))

    # Isn't numeric, so we assume it's a character
    return list(char_range(first, second))


DRF_list = Union[str, List[str], Tuple[str, ...]]


def generate(*drf_globs: DRF_list) -> List[str]:
    """
    Generates a list of valid requests from a DRF glob.

    :param drf_globs: A list of DRF globs.
    :return: A list of valid requests.
    """
    results = []

    def parse_globs(drf_globs):
        for drf_glob in drf_globs:
            # Parse nested lists and tuples
            if type(drf_glob) in [list, tuple]:
                parse_globs(drf_glob)
                break

            tokens = re.split(r'[{}]', drf_glob)
            iterations = []

            for token in tokens:
                if '..' in token:
                    first, second = token.split('..')
                    iterations.append(token_range(first, second))
                elif ',' in token:
                    iterations.append(token.split(','))
                else:
                    if token != '':
                        iterations.append([token])

            for result in product(*iterations):
                results.append(''.join(map(str, result)))

    parse_globs(drf_globs)

    return results


PathLike = Union[str, Path]


def verify(test_file: PathLike, *globs: str) -> List[str]:
    """
    Verifies that a test file contains all the valid requests generated by
    the given DRF globs.

    :param test_file: The test file to verify.
    :param globs: A list of DRF globs.
    :return: A list of the unmatched requests.
    """
    test_requests = generate(globs)
    valid_results = []

    with open(test_file) as file:
        for line in file.readlines():
            valid_results.append(line.strip())

    no_matches = []

    for request in valid_results:
        if request not in test_requests:
            no_matches.append(request)

    return no_matches
